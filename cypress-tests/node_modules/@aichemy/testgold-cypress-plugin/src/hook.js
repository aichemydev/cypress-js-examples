const { getInterceptorConfig, getTagMutationTable, startTestRequest,
  serializeWebElement, getSelectorId, findSimilarElements, getPageProperties, awaitableTimeout } = require('./utils')
const { cssRequest } = require('./cssRequest')

/**
 * Runs the actual interceptor hook to talk to the WAL server and heal selector
 * @param selector
 * @param Cypress
 * @param cy
 * @param state
 * @param walServerRequestId
 * @param interceptorConfig
 * @returns Object
 */
export async function interceptorHook (
  selector,
  Cypress, cy, state,
  walServerRequestId = null,
  interceptorConfig = null,
) {
  // check if the selector is actually an alias starting with the '@' character
  if (selector.startsWith('@')) {
    return {
      status: 'interceptor disabled, selector is an alias',
      config: interceptorConfig,
    }
  }

  // check if the interceptor is enabled
  if (interceptorConfig === null) {
    interceptorConfig = getInterceptorConfig(Cypress)
  }

  let interceptorResult = {
    status: 'interceptor disabled',
    config: interceptorConfig,
  }

  // if it's not, return immediately
  if (interceptorConfig.tgEnabled === false) {
    return interceptorResult
  }

  Cypress.log({
    name: '[TGI]',
    message: `ðŸ”„ Processing selector: ${selector}`,
  })

  // sequence:
  // 1. get the tag mutation table
  // 2. get the test request ID
  // 3. collect body HTML and page properties
  // 4. collect selected element info and decide whether to trigger healing

  try {
    // get a new walServerRequestId if one is not provided
    if (walServerRequestId === null) {
      walServerRequestId = await startTestRequest(Cypress, interceptorConfig)
    }

    if (walServerRequestId === null) {
      interceptorResult['status'] = 'interceptor disabled'

      return interceptorResult
    }

    let tagMutationTable

    try {
      tagMutationTable = await getTagMutationTable(interceptorConfig)
    } catch (err) {
      tagMutationTable = null
    }

    //
    // start the interceptor processing
    //

    // put the selector, walServerRequestId, and interceptorConfig into the interceptorResult
    interceptorResult['selector'] = selector
    interceptorResult['walServerRequestId'] = walServerRequestId
    interceptorResult['interceptorConfig'] = interceptorConfig
    interceptorResult['specFileName'] = Cypress.spec.name

    // NOTE: this is the REMOTE window object (i.e. the one under test)
    //   using Cypress.$(window) would have given us the window object of the
    //   Cypress runner itself (which includes the remote window in a frame)
    let $window = state('window')
    let $document = state('document')

    // try 8 times and wait for 250 ms + random
    // before each try for things to
    // settle before running the jQuery select -- replicates ~4 second Cypress timeout
    const maxTries = 8
    let nTries = 0

    let $result = []
    let randomWait = 0

    while (nTries < maxTries) {
      randomWait = Math.round(1000 * Math.abs(Math.random() - 0.5))
      await awaitableTimeout(250 + randomWait)
      $result = Cypress.$(selector)
      if ($result.length > 0) {
        break
      }

      nTries = nTries + 1
    }

    // get the other properties after the target element selection is resolved

    let pageUrl = $window.location.href
    // break up the pageUrl into its components
    let { pathname: urlPath } = new URL(pageUrl)

    // make JS follow Python and Java
    if (urlPath === '/') {
      urlPath = ''
    }

    // get the selectorId and put it into the interceptorResult object
    let selectorId = await getSelectorId(selector, urlPath)

    interceptorResult['selectorId'] = selectorId

    // REMOTE body object (since Cypress.$('<something>') is scoped to the REMOTE window)
    let $body = Cypress.$('body')[0]
    let bodyHtml = $body.parentNode.outerHTML

    // attempt to scroll to the target element before further processing (+ screenshot)
    if ($result.length > 0) {
      $result[0].scrollIntoView()
      await awaitableTimeout(500)
    }

    // page properties
    let pageProperties = getPageProperties($window, $document, Cypress)

    interceptorResult['pageProperties'] = pageProperties

    //
    // if selector succeeded - run the train-flow
    //

    if ($result.length > 0) {
      Cypress.log({
        name: '[TGI]',
        message: `âœ… Selector: ${selector} succeeded. Starting train-flow...`,
      })

      // tell the interceptorResult what kind of request will be sent
      interceptorResult['postRequestType'] = 'initial'

      let serializedWebElement = serializeWebElement($window, $result[0], Cypress, cy)

      // get the similar web elements
      let similarWebElements = await findSimilarElements(
        serializedWebElement,
        selector,
        selectorId,
        $window,
        $document,
        tagMutationTable,
        interceptorConfig,
        Cypress,
        cy,
      )

      // generate the train request and send it
      let trainRequest = new cssRequest(
        selector,
        pageUrl,
        'initial',
        interceptorConfig['walServerHost'],
        interceptorConfig['walAuthToken'],
        interceptorConfig['walServerUser'],
        walServerRequestId,
        interceptorConfig['walServerTimeout'],
      )

      trainRequest.selectorId = selectorId
      trainRequest.addBodyHTML(bodyHtml)
      trainRequest.addSelectedElement(serializedWebElement)
      trainRequest.addSimilarElements(similarWebElements)

      trainRequest.addBrowserProperties(
        pageProperties['viewportWidth'],
        pageProperties['viewportHeight'],
        pageProperties,
      )

      // FIXME: can't do screenshots yet
      trainRequest.addScreenshot(null)

      // send the train request
      await trainRequest.sendTrainPostRequest()

      interceptorResult['status'] = 'trained successfully'
      interceptorResult['postSentAt'] = trainRequest.sentAt

      return interceptorResult
    }

    //
    // heal-flow -- if the element was not found
    //
    Cypress.log({
      name: '[TGI]',
      message: `âš ï¸ Selector: ${selector} failed. Starting heal-flow...`,
      consoleProps: () => {
        return interceptorConfig
      },
    })

    // divert to fast-heal if requested
    if (interceptorConfig['interceptorFastHeal'] === true) {
      Cypress.log({
        name: '[TGI]',
        message: `âš ï¸ Fast-heal requested for selector: ${selector}...`,
      })

      let fastHealRequest = new cssRequest(
        selector,
        pageUrl,
        'fastHeal',
        interceptorConfig['walServerHost'],
        interceptorConfig['walAuthToken'],
        interceptorConfig['walServerUser'],
        walServerRequestId,
        interceptorConfig['walServerTimeout'],
      )

      fastHealRequest.selectorId = selectorId
      fastHealRequest.addBodyHTML(bodyHtml)

      // send the fast-heal request
      let fastHealResp = await fastHealRequest.sendFastHealRequest()

      if (fastHealResp['status'] === 'success' || fastHealResp['status'] === 'warning') {
        interceptorResult['healedSelector'] = fastHealResp['bestSelector']
        interceptorResult['status'] = 'selector failed, heal OK'
        interceptorResult['processingType'] = 'heal'
        interceptorResult['details'] = fastHealResp

        Cypress.log({
          name: '[TGI]',
          message: `âš›ï¸ The TG API fast-healed this to: ${interceptorResult['healedSelector']}.`,
        })

        // NOTE: we haven't updated postSentAt and postRequestType in the interceptorResult
        // this means the screenshot won't trigger for this item (the TG API will re-use the old
        // screenshot from the previous heal result)
        return interceptorResult
      }

      Cypress.log({
        name: '[TGI]',
        message: `âš ï¸ Fast-heal failed for selector: ${selector}.`,
      })
    }

    //
    // if fast-heal didn't work, continue with normal-heal
    //

    // tell the interceptorResult what kind of request will be sent
    interceptorResult['postRequestType'] = 'followup'

    // get the similar web elements -- pass null to the serializedWebElement param to signal
    // this will be a followup request
    let similarWebElements = await findSimilarElements(
      null,
      selector,
      selectorId,
      $window,
      $document,
      tagMutationTable,
      interceptorConfig,
      Cypress,
      cy,
    )

    // generate the followup request
    let followupRequest = new cssRequest(
      selector,
      pageUrl,
      'followup',
      interceptorConfig['walServerHost'],
      interceptorConfig['walAuthToken'],
      interceptorConfig['walServerUser'],
      walServerRequestId,
      interceptorConfig['walServerTimeout'],
    )

    // add in the required items
    followupRequest.selectorId = selectorId
    followupRequest.addBodyHTML(bodyHtml)
    followupRequest.addSimilarElements(similarWebElements)

    followupRequest.addBrowserProperties(
      pageProperties['viewportWidth'],
      pageProperties['viewportHeight'],
      pageProperties,
    )

    // screenshots are sent out of band
    followupRequest.addScreenshot(null)

    // send the followup request
    let followupResp = await followupRequest.sendTrainPostRequest()

    interceptorResult['postSentAt'] = followupRequest.sentAt

    // if the followup POST was accepted, start waiting for the heal response
    // and handle it
    if (followupResp['status'] !== 'failed') {
      let healResp = await followupRequest.sendHealOrSuggestGetRequest('heal', Cypress)

      if (healResp['status'] === 'success' || healResp['status'] === 'warning') {
        interceptorResult['healedSelector'] = healResp['bestSelector']
        interceptorResult['status'] = 'selector failed, heal OK'
        interceptorResult['processingType'] = 'heal'
        interceptorResult['details'] = healResp

        Cypress.log({
          name: '[TGI]',
          message: `âš›ï¸ The TG API healed this to: ${interceptorResult['healedSelector']}.`,
        })

        // reselect the element
        // $result = Cypress.$(interceptorResult['healedSelector'])

        // attempt to scroll to the target element before further processing (+ screenshot)
        // FIXME: can't scroll here because we would destroy the
        //  document state as it was processed for the followup run
        //  so all the element coords would be off
        // if ($result.length > 0) {
        //   $result[0].scrollIntoView()
        //   await awaitableTimeout(500)
        // }

        return interceptorResult
      }
    }

    // otherwise, the follow-up request was not accepted, then we need to fall back to
    // css-suggest if the interceptor is setup to do so
    if (interceptorConfig['interceptorHandleFailure'] === 'suggest-xpaths') {
      Cypress.log({
        name: '[TGI]',
        message: `âš ï¸ Selector: ${selector} could not be healed. Starting suggest-flow...`,
      })

      // tell the interceptorResult what kind of request will be sent
      interceptorResult['postRequestType'] = 'suggest'

      // send the suggest POST request to make the WAL server aware
      let suggestPostResp = await followupRequest.sendSuggestPostRequest()

      interceptorResult['postSentAt'] = followupRequest.sentAt

      if (suggestPostResp === null || suggestPostResp === undefined) {
        interceptorResult['status'] = 'failed'
        interceptorResult['processingType'] = 'suggest'

        Cypress.log({
          name: '[TGI]',
          message: 'âŽ The TG API had no training data for this selector and could not suggest an alternative.',
        })

        return interceptorResult
      }

      // get back the suggestion results
      let suggestGetResp = await followupRequest.sendHealOrSuggestGetRequest('suggest', Cypress)

      if (suggestGetResp['status'] === 'success' || suggestGetResp['status'] === 'warning') {
        if (suggestGetResp['suggestedFixes'] !== null) {
          interceptorResult['healedSelector'] = suggestGetResp['suggestedFixes']['candidateSelectors'][0]
          interceptorResult['status'] = 'selector failed, heal OK'
          interceptorResult['processingType'] = 'suggest'
          interceptorResult['details'] = suggestGetResp

          Cypress.log({
            name: '[TGI]',
            message: 'âš›ï¸ The TG API had no training data for this selector.',
          })

          Cypress.log({
            name: '[TGI]',
            message: `âš›ï¸ The best-effort heal attempt returned an alternative selector: ${interceptorResult['healedSelector']}.`,
          })

          Cypress.log({
            name: '[TGI]',
            message: `âš›ï¸ Please check if this selector works as expected.`,
          })

          // reselect the element
          // $result = Cypress.$(interceptorResult['healedSelector'])

          // attempt to scroll to the target element before further processing (+ screenshot)
          // FIXME: can't scroll here because we would destroy the
          //  document state as it was processed for the followup run
          //  so all the element coords would be off
          // if ($result.length > 0) {
          //   $result[0].scrollIntoView()
          //   await awaitableTimeout(500)
          // }

          return interceptorResult
        }

        //
        // if the suggestGetResp is null, the WAL server failed
        //
        interceptorResult['status'] = 'failed'
        interceptorResult['processingType'] = 'suggest'
        interceptorResult['details'] = suggestGetResp

        Cypress.log({
          name: '[TGI]',
          message: 'âŽ The TG API had no training data for this selector and could not suggest an alternative.',
        })

        return interceptorResult
      }
    }

    //
    // interceptorHandleFailure is not set to 'suggest-xpaths', so we can't use suggestions
    //
    Cypress.log({
      name: '[TGI]',
      message: 'âŽ The TG API had no training data for this selector and could not suggest an alternative.',
    })

    interceptorResult['status'] = 'failed'

    return interceptorResult
  } catch (err) {
    // catch all other errors and error out
    interceptorResult['status'] = 'failed'
    Cypress.log({
      name: '[TGI]',
      message: `â›”ï¸ Selector: ${selector} failed. Interceptor raised an exception.`,
      consoleProps: () => {
        return {
          'error': err,
          'stackTrace': (new Error()).stack,
        }
      },
    })

    return interceptorResult
  }
}
